---
title: "ST 558: Project 1"
author: Kayla Kippes and Zack Rosen
date: 6/16/2025
format: pdf
editor: visual
---

For this project, our goal was to manipulate and process data sets that came in a certain form. To start this process, we completed each individual step on one data set. This allowed us to ensure the content of our functions would be working properly. Then we added each of those steps into their respective functions. After that we created a wrapper function to pull everything into one place. From there we combined the necessary data sets and performed unique types of the plot function. The rest of this document will talk through each function and give examples of all of our functions coming together to be used on actual data.

## Function 1: Read and Convert Data

** Zack insert here **

```{r}
#| warning: false
#| message: false

library(tidyverse)

read_and_preprocess <- function(data, column_name = "enrollment") {
  # Step 1
  ## select / rename columns
  EDU01a <- data |>
    select(Area_name, STCOU, ends_with("D")) |>
    rename("area_name" = "Area_name")
  ## print out the first 5 rows
  head(EDU01a, 5)
  
  # Step 2
  # pivot cols 3-12 into long format
  long_tibble <- EDU01a |>
    pivot_longer(cols = 3:12, names_to = "survey_value", values_to = column_name)
  ## print out the first 5 rows
  head(long_tibble, 5)
  
  ##return long data
  return(long_tibble)
}
```

## Function 2: Parsing the Data and Creating New Varaiables

In order to parase the data and create new variables, We figured "mutate" would have to be used. Since each year was embedded into the "survery_value" column and every value in that column was the same length, we were able to sub string the year out and make it a numeric. However, this only gave me two digits and we wanted four digit years. To solve for this, we added an "if" statement to add either 1900 or 2000 to my two digit year (this wouldn't have worked if the data includes years below 1925). Also, we had made a temporary column initially with the short year so we decided to select all other columns except for the one that wasn't needed.

```{r}
parase_new_variables <- function(long_tibble) {
  long_updated <- long_tibble |> 
  mutate(short_year = as.numeric(substr(survey_value, 8, 9)), 
         year = ifelse(short_year > 25, 1900 + short_year, 2000 + short_year),
         measurement = substr(survey_value, 1, 7)) |>
  select(-short_year)
  ## print out the first 5 rows
  head(long_updated, 5)
  
  ## returns long updated
  return(long_updated)
}
```

## Function 3: County Level

Similar to the year scenario above, we had to use "substr" to create a state column for the county data. This was a bit tricker as the values in area_name were not all the same length. To solve for this, we need to grab the max number of characters in the string and pull the second to last and last one so we could get the two character state value.

```{r}
## add state column
add_state_col_county <- function(county_tibble) {
  county_tibble <- county_tibble |>
  mutate(state = substr(area_name, nchar(area_name) - 1, nchar(area_name)))
  ## return the tibble
  return(county_tibble)
}
```


## Function 4: Non-County Level

** Zack insert here **

```{r}
add_division_col_state <- function(state_tibble) {
  # Step 6
  ## create division variable and set division by state name, else ERROR
  state_tibble <- state_tibble |>
    mutate(division = case_when(
      area_name %in% c("CONNECTICUT", "MAINE", "MASSACHUSETTS", "NEW HAMPSHIRE", 
                       "RHODE ISLAND", "VERMONT") ~ "New England",
      area_name %in% c("NEW JERSEY", "NEW YORK", "PENNSYLVANIA") ~ "Mid-Atlantic",
      area_name %in% c("ILLINOIS", "INDIANA", "MICHIGAN", "OHIO", 
                       "WISCONSIN") ~ "East North Central",
      area_name %in% c("IOWA", "KANSAS", "MINNESOTA", "MISSOURI", "NEBRASKA", 
                       "NORTH DAKOTA", "SOUTH DAKOTA") ~ "West North Central",
      area_name %in% c("DELAWARE", "DISTRICT OF COLUMBIA", "FLORIDA", "GEORGIA", 
                       "MARYLAND", "NORTH CAROLINA", "SOUTH CAROLINA", "VIRGINIA", 
                       "WEST VIRGINIA") ~ "South Atlantic",
      area_name %in% c("ALABAMA", "KENTUCKY", "MISSISSIPPI", 
                       "TENNESSEE") ~ "East South Central",
      area_name %in% c("ARKANSAS", "LOUISIANA", "OKLAHOMA", 
                       "TEXAS") ~ "West South Central",
      area_name %in% c("ARIZONA", "COLORADO", "IDAHO", "MONTANA", "NEVADA", 
                       "NEW MEXICO", "UTAH", "WYOMING") ~ "Mountain",
      area_name %in% c("ALASKA", "CALIFORNIA", "HAWAII", "OREGON", 
                       "WASHINGTON") ~ "Pacific",
      TRUE ~ "ERROR"))
  return(state_tibble)
}
```

## Function 5: Returning Two Final Tibbles

** Zack insert here **

```{r}
create_datasets <- function(long_updated) {
  # Step 4
  ## get the county indices
  county_indices <- grep(pattern = ", \\w\\w", long_updated$area_name)
  ## create the non-county data
  state_tibble <- long_updated[-county_indices,]
  ## create the county data
  county_tibble <- long_updated[county_indices,]
  ## add a class to the county tibble
  class(county_tibble) <- c("county", class(county_tibble))
  ## print out the first 10 rows
  head(state_tibble, 10)
  head(county_tibble, 10)
  
  final_county_tibble <- add_state_col_county(county_tibble)
  final_state_tibble <- add_division_col_state(state_tibble)
  return(list(county = final_county_tibble, state = final_state_tibble))
}
```

## Wrapper Function

The outline for this one was very helpful as it pointed me to the format. Besides the initial csv read, we don't define any variables for my other functions because we assume the output of the previous function will be used as input for the next function. This makes it easier as their are less things to input.

```{r}
my_wrapper <- function(url, default_var_name = "enrollment"){
  result <- read_csv(url) |>
    read_and_preprocess() |>
    parase_new_variables() |>
    create_datasets()
 ## return final result
  return(result)
 }
```

## Combine Function

Here we are doing a simple combination of all the specific county and state data.

```{r}
combine_results <- function(result1, result2) {
  list(combined_county = dplyr::bind_rows(result1$county, result2$county),
       combined_state = dplyr::bind_rows(result1$state, result2$state))
}
```

## Custom Plot Function

We created our own classes by writing custom plot functions, unique to our data.

### State

** Zack insert here **

```{r}
library(dplyr)
library(ggplot2)

plot.state <- function(df, var_name = "enrollment") {
  df |>
    filter(division != "ERROR") |>
    group_by(division, year) |>
    summarize(mean = mean(get(var_name)), .groups = "drop") |>
    ggplot(aes(x = year, y = mean, color = division)) +
    geom_line() +
    labs(title = paste("Mean", var_name, "across years by division"),
         y = paste("Mean", var_name),
         x = "Year")
}
```

### County

To start this plot county function, a certain state had to be filtered. This helped narrow down the data set. From there we had to group by area name in order to get our mean statistics. The difficult part about arranging these statistics was that it was dependent on an inputted value so we had to imply if else logic. After that we only choose the n number of specified rows. That was now considered our sorted data but we didn't want to only use that data for the plot. Instead we had to go back to our original filtered data and filter it again to only include the area names in the top or bottom n records. To view this neatly, we decided a box plot would be the best visualization.

```{r}
plot.county <- function(county_tibble, var_name = "enrollment", state = "NC", direction = "top", n = 5) {
  ## filter for the selected state
  filtered_state <- county_tibble |>
    filter(state == state)
  
  ## find the mean by area_name and sort the data
  sorted_data <- filtered_state |>
    group_by(area_name) |>
    summarize(mean_val = mean(get(var_name), na.rm = TRUE)) |>
    arrange(if (direction == "top") {
      desc(mean_val)
    } else {
      mean_val
    }) |>
    slice_head(n = n)
  
  ## filter for state from above
  new_sorted_data <- filtered_state |>
    filter(area_name %in% sorted_data$area_name)
  
  ## plot the statistic
  ggplot(new_sorted_data, aes(x = area_name, y = get(var_name))) + 
    geom_boxplot() + 
    labs(title = paste(direction, n, "Counties in", state),
         y = var_name,
         x = "County") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}
```


## Putting it All Together

Here we put it all together using two data sets and then using a different four data sets.

### Two Enrollment Datasets

The goal here was to process two different data sets and save the results to their own respective variables. After that, we combined those results so we are left with a list that contains a combined state data frame and a combined tibble data frame. From there we used our state plot function to give us mean enrollment by division over time. Then we use the county plot function to retrieve a certain number of box plots of the enrollment data for the top or bottom area names in a specified state.

```{r}
#| warning: false
#| message: false

## using data processing on two enrollment urls
result1 <- my_wrapper("data/EDU01a.csv")
result2 <- my_wrapper("data/EDU01b.csv")

## combining data sets
combined_results <- combine_results(result1, result2)

## use plot function on state
plot.state(combined_results$combined_state)

## use plot on county data
## scenario one
plot.county(combined_results$combined_county, state = "NC", direction="top", n = 20)
## scenario two
plot.county(combined_results$combined_county, state = "SC", direction="bottom", n = 7)
## scenario three
plot.county(combined_results$combined_county)
##scenario four
plot.county(combined_results$combined_county, state = "PA", direction="top", n = 8)

```

### Four Additional Data Sets

** Zack insert here **