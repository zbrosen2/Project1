---
title: "ST 558: Project 1"
author: Kayla Kippes and Zack Rosen
date: 6/16/2025
format: pdf
editor: visual
---

## Function 1: Read and Convert Data

```{r}
message: false
warning: false

library(tidyverse)

read_and_preprocess <- function(data, column_name = "enrollment") {
  # Step 1
  ## select / rename columns
  EDU01a <- data |>
    select(Area_name, STCOU, ends_with("D")) |>
    rename("area_name" = "Area_name")
  ## print out the first 5 rows
  head(EDU01a, 5)
  
  # Step 2
  # pivot cols 3-12 into long format
  long_tibble <- EDU01a |>
    pivot_longer(cols = 3:12, names_to = "survey_value", values_to = column_name)
  ## print out the first 5 rows
  head(long_tibble, 5)
  
  ##return long data
  return(long_tibble)
}
```

## Function 2: Parsing the Data and Creating New Varaiables

```{r}
parase_new_variables <- function(long_tibble) {
  long_updated <- long_tibble |> 
  mutate(short_year = as.numeric(substr(survey_value, 8, 9)), 
         year = ifelse(short_year > 25, 1900 + short_year, 2000 + short_year),
         measurement = substr(survey_value, 1, 7)) |>
  select(-short_year)
  ## print out the first 5 rows
  head(long_updated, 5)
  
  ## returns long updated
  return(long_updated)
}
```

## Function 3: County Level

```{r}
## add state column
add_state_col_county <- function(county_tibble) {
  county_tibble <- county_tibble |>
  mutate(state = substr(area_name, nchar(area_name) - 1, nchar(area_name)))
  ## return the tibble
  return(county_tibble)
}
```


## Function 4: Non-County Level

```{r}
add_division_col_state <- function(state_tibble) {
  # Step 6
  ## create division variable and set division by state name, else ERROR
  state_tibble <- state_tibble |>
    mutate(division = case_when(
      area_name %in% c("CONNECTICUT", "MAINE", "MASSACHUSETTS", "NEW HAMPSHIRE", 
                       "RHODE ISLAND", "VERMONT") ~ "New England",
      area_name %in% c("NEW JERSEY", "NEW YORK", "PENNSYLVANIA") ~ "Mid-Atlantic",
      area_name %in% c("ILLINOIS", "INDIANA", "MICHIGAN", "OHIO", 
                       "WISCONSIN") ~ "East North Central",
      area_name %in% c("IOWA", "KANSAS", "MINNESOTA", "MISSOURI", "NEBRASKA", 
                       "NORTH DAKOTA", "SOUTH DAKOTA") ~ "West North Central",
      area_name %in% c("DELAWARE", "DISTRICT OF COLUMBIA", "FLORIDA", "GEORGIA", 
                       "MARYLAND", "NORTH CAROLINA", "SOUTH CAROLINA", "VIRGINIA", 
                       "WEST VIRGINIA") ~ "South Atlantic",
      area_name %in% c("ALABAMA", "KENTUCKY", "MISSISSIPPI", 
                       "TENNESSEE") ~ "East South Central",
      area_name %in% c("ARKANSAS", "LOUISIANA", "OKLAHOMA", 
                       "TEXAS") ~ "West South Central",
      area_name %in% c("ARIZONA", "COLORADO", "IDAHO", "MONTANA", "NEVADA", 
                       "NEW MEXICO", "UTAH", "WYOMING") ~ "Mountain",
      area_name %in% c("ALASKA", "CALIFORNIA", "HAWAII", "OREGON", 
                       "WASHINGTON") ~ "Pacific",
      TRUE ~ "ERROR"))
  return(state_tibble)
}
```

## Function 5: Returning Two Final Tibbles

```{r}
create_datasets <- function(long_updated) {
  # Step 4
  ## get the county indices
  county_indices <- grep(pattern = ", \\w\\w", long_updated$area_name)
  ## create the non-county data
  state_tibble <- long_updated[-county_indices,]
  ## create the county data
  county_tibble <- long_updated[county_indices,]
  ## add a class to the county tibble
  class(county_tibble) <- c("county", class(county_tibble))
  ## print out the first 10 rows
  head(state_tibble, 10)
  head(county_tibble, 10)
  
  final_county_tibble <- add_state_col_county(county_tibble)
  final_state_tibble <- add_division_col_state(state_tibble)
  return(list(county = final_county_tibble, state = final_state_tibble))
}
```

## Wrapper Function

```{r}
my_wrapper <- function(url, default_var_name = "enrollment"){
  result <- read_csv(url) |>
    read_and_preprocess() |>
    parase_new_variables() |>
    create_datasets()
 ## return final result
  return(result)
 }
```

## Combine Function

```{r}
combine_results <- function(result1, result2) {
  list(combined_county = dplyr::bind_rows(result1$county, result2$county),
       combined_state = dplyr::bind_rows(result1$state, result2$state))
}
```

## Custom Plot Function

### State

```{r}
plot.state <- function(df, var_name = "enrollment") {
  df |>
    filter(division != "ERROR") |>
    group_by(division, year) |>
    summarize(mean = mean(get(var_name)), .groups = "drop") |>
    ggplot(aes(x = year, y = mean, color = division)) +
    geom_line() +
    labs(title = paste("Mean", var_name, "across years by division"),
         y = paste("Mean", var_name),
         x = "Year")
}
```

### County
```{r}
library(dplyr)
library(ggplot2)

plot.county <- function(county_tibble, var_name = "enrollment", state = "NC", direction = "top", n = 5) {
  ## filter for the selected state
  filtered_state <- county_tibble |>
    filter(state == state)
  
  ## find the mean by area_name and sort the data
  sorted_data <- filtered_state |>
    group_by(area_name) |>
    summarize(mean_val = mean(get(var_name), na.rm = TRUE)) |>
    arrange(if (direction == "top") {
      desc(mean_val)
    } else {
      mean_val
    }) |>
    slice_head(n = n)
  
  ## filter for state from above
  new_sorted_data <- filtered_state |>
    filter(area_name %in% sorted_data$area_name)
  
  ## plot the statistic
  ggplot(new_sorted_data, aes(x = area_name, y = get(var_name))) + geom_boxplot() + 
    labs(title = paste(direction, n, "Counties in", state),
         y = var_name,
         x = "County")
}
```


## Putting it All Together

### Data Processing Function

### Data Combining Function

### Plot Function on State

### Plot Function on County

### Repeating the Process For Additional Data Sets

### Plot Function